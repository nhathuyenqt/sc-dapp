{"ast":null,"code":"/** @license | xtypejs v0.7.1 | (c) 2015, Lucas Ononiwu | MIT license, xtype.js.org/license.txt\n */\n\n/**\n * The MIT License (MIT)\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n(function (root, undefined) {\n  'use strict';\n  /*\n  * --------------\n  * MODULE GLOBALS\n  * --------------\n  */\n\n  var LIB_NAME = 'xtype',\n      LIB_VERSION = '0.7.1',\n      TYPE_DELIMITER_DEFAULT_PATTERN = '[|, ]',\n      NAME_SCHEME_DEFAULT_OPTION_VALUE = 'default',\n      OBJECT_CLASS_REGEX = /^\\[object\\s(.*)\\]$/,\n      MAX_REQUEST_TYPE_CACHE_SIZE = 250,\n\n  /* --- Extensions and Module Refresh --- */\n  registeredExtensions = [],\n\n  /* --- Localized function references --- */\n  Array = [].constructor || Array,\n      isArray = Array.isArray,\n      arrayPush = Array.prototype.push,\n      arraySlice = Array.prototype.slice,\n      Object = {}.constructor || Object,\n      objCreate = Object.create,\n      objKeys = Object.keys,\n      objToString = Object.prototype.toString,\n      newObj = function () {\n    return objCreate(null);\n  },\n\n  /*\n  * -----------\n  * BASE TYPES \n  * -----------\n  */\n  NONE_TYPE = 0,\n      // No type\n\n  /*  Nothing types  */\n  NULL = 1 << 0,\n      UNDEFINED = 1 << 1,\n      NAN = 1 << 2,\n\n  /* Boolean */\n  TRUE = 1 << 3,\n      FALSE = 1 << 4,\n\n  /*  String  */\n  EMPTY_STRING = 1 << 5,\n      // String with zero characters.\n  WHITESPACE = 1 << 6,\n      // String with one or more of only whitespace characters.\n  SINGLE_CHAR_STRING = 1 << 7,\n      // String with exactly one non-whitespace and zero or more whitespace characters.\n  MULTI_CHAR_STRING = 1 << 8,\n      // String with more than one non-whitespace and zero or more whitespace characters.\n\n  /* Number */\n  ZERO = 1 << 9,\n      POSITIVE_INTEGER = 1 << 10,\n      POSITIVE_FLOAT = 1 << 11,\n      POSITIVE_INFINITY = 1 << 12,\n      NEGATIVE_INTEGER = 1 << 13,\n      NEGATIVE_FLOAT = 1 << 14,\n      NEGATIVE_INFINITY = 1 << 15,\n\n  /* Array */\n  EMPTY_ARRAY = 1 << 16,\n      SINGLE_ELEM_ARRAY = 1 << 17,\n      MULTI_ELEM_ARRAY = 1 << 18,\n\n  /* Object */\n  EMPTY_OBJECT = 1 << 19,\n      SINGLE_PROP_OBJECT = 1 << 20,\n      MULTI_PROP_OBJECT = 1 << 21,\n\n  /*  ECMA types  */\n  SYMBOL = 1 << 22,\n      FUNCTION = 1 << 23,\n      DATE = 1 << 24,\n      ERROR = 1 << 25,\n      REGEXP = 1 << 26,\n\n  /*\n  * --------------\n  * DERIVED TYPES \n  * --------------\n  */\n\n  /*  Derived Simple types  */\n  BOOLEAN = TRUE | FALSE,\n      STRING = EMPTY_STRING | WHITESPACE | SINGLE_CHAR_STRING | MULTI_CHAR_STRING,\n      NUMBER = POSITIVE_INTEGER | POSITIVE_FLOAT | POSITIVE_INFINITY | NEGATIVE_INTEGER | NEGATIVE_FLOAT | NEGATIVE_INFINITY | ZERO,\n      ARRAY = EMPTY_ARRAY | SINGLE_ELEM_ARRAY | MULTI_ELEM_ARRAY,\n      OBJECT = EMPTY_OBJECT | SINGLE_PROP_OBJECT | MULTI_PROP_OBJECT,\n\n  /*  Other derived types  */\n  BLANK_STRING = EMPTY_STRING | WHITESPACE,\n      NON_EMPTY_STRING = WHITESPACE | SINGLE_CHAR_STRING | MULTI_CHAR_STRING,\n      NON_BLANK_STRING = SINGLE_CHAR_STRING | MULTI_CHAR_STRING,\n      FLOAT = POSITIVE_FLOAT | NEGATIVE_FLOAT,\n      INTEGER = POSITIVE_INTEGER | NEGATIVE_INTEGER | ZERO,\n      INFINITE_NUMBER = POSITIVE_INFINITY | NEGATIVE_INFINITY,\n      NON_INFINITE_NUMBER = INTEGER | FLOAT,\n      POSITIVE_NUMBER = POSITIVE_INTEGER | POSITIVE_FLOAT | POSITIVE_INFINITY,\n      NEGATIVE_NUMBER = NEGATIVE_INTEGER | NEGATIVE_FLOAT | NEGATIVE_INFINITY,\n      NON_ZERO_NUMBER = POSITIVE_NUMBER | NEGATIVE_NUMBER,\n      NON_NEGATIVE_NUMBER = POSITIVE_NUMBER | ZERO,\n      NON_POSITIVE_NUMBER = NEGATIVE_NUMBER | ZERO,\n      NON_EMPTY_OBJECT = SINGLE_PROP_OBJECT | MULTI_PROP_OBJECT,\n      NON_EMPTY_ARRAY = SINGLE_ELEM_ARRAY | MULTI_ELEM_ARRAY,\n      NOTHING = NULL | UNDEFINED,\n      PRIMITIVE = STRING | NUMBER | BOOLEAN | SYMBOL,\n      // Composite of all base types (effectively all derived and non-derived types)\n  ANY_TYPE = NULL | UNDEFINED | NAN | SYMBOL | FUNCTION | DATE | ERROR | REGEXP | TRUE | FALSE | EMPTY_STRING | WHITESPACE | SINGLE_CHAR_STRING | MULTI_CHAR_STRING | ZERO | POSITIVE_INTEGER | POSITIVE_FLOAT | POSITIVE_INFINITY | NEGATIVE_INTEGER | NEGATIVE_FLOAT | NEGATIVE_INFINITY | EMPTY_ARRAY | SINGLE_ELEM_ARRAY | MULTI_ELEM_ARRAY | EMPTY_OBJECT | SINGLE_PROP_OBJECT | MULTI_PROP_OBJECT,\n      // Composite of all derived types (Internal)\n  DERIVED_TYPE = BOOLEAN | STRING | NUMBER | ARRAY | OBJECT;\n\n  var TYPE_VALUE_MAPPING = {\n    // -- Absent --\n    'null': NULL,\n    'undefined': UNDEFINED,\n    nan: NAN,\n    // -- Boolean --\n    boolean: BOOLEAN,\n    'true': TRUE,\n    'false': FALSE,\n    // -- String --\n    string: STRING,\n    empty_string: EMPTY_STRING,\n    whitespace: WHITESPACE,\n    single_char_string: SINGLE_CHAR_STRING,\n    multi_char_string: MULTI_CHAR_STRING,\n    // Composite\n    blank_string: BLANK_STRING,\n    non_empty_string: NON_EMPTY_STRING,\n    non_blank_string: NON_BLANK_STRING,\n    // -- Number --\n    number: NUMBER,\n    zero: ZERO,\n    positive_integer: POSITIVE_INTEGER,\n    positive_float: POSITIVE_FLOAT,\n    positive_infinity: POSITIVE_INFINITY,\n    negative_integer: NEGATIVE_INTEGER,\n    negative_float: NEGATIVE_FLOAT,\n    negative_infinity: NEGATIVE_INFINITY,\n    // Composite\n    integer: INTEGER,\n    float: FLOAT,\n    infinite_number: INFINITE_NUMBER,\n    positive_number: POSITIVE_NUMBER,\n    negative_number: NEGATIVE_NUMBER,\n    non_infinite_number: NON_INFINITE_NUMBER,\n    non_positive_number: NON_POSITIVE_NUMBER,\n    non_negative_number: NON_NEGATIVE_NUMBER,\n    non_zero_number: NON_ZERO_NUMBER,\n    // -- Array --\n    array: ARRAY,\n    empty_array: EMPTY_ARRAY,\n    single_elem_array: SINGLE_ELEM_ARRAY,\n    multi_elem_array: MULTI_ELEM_ARRAY,\n    non_empty_array: NON_EMPTY_ARRAY,\n    // -- Object --\n    object: OBJECT,\n    empty_object: EMPTY_OBJECT,\n    single_prop_object: SINGLE_PROP_OBJECT,\n    multi_prop_object: MULTI_PROP_OBJECT,\n    non_empty_object: NON_EMPTY_OBJECT,\n    // -- Other --\n    symbol: SYMBOL,\n    date: DATE,\n    error: ERROR,\n    regexp: REGEXP,\n    'function': FUNCTION,\n    nothing: NOTHING,\n    primitive: PRIMITIVE,\n    any: ANY_TYPE,\n    none: NONE_TYPE\n  };\n  /* Custome Typeof */\n\n  var TYPEOF_NULL = 'null',\n      TYPEOF_NAN = 'nan';\n  /*\n  * --------------\n  * MODULE FACTORY\n  * --------------\n  */\n\n  function newModuleInstance() {\n    var moduleRefreshHandlers = [],\n        nameSchemes = newObj(),\n        activeNameScheme,\n        isAliasMode = false,\n        typeDelimiterRegExp,\n\n    /* Type list string memoization cache */\n    typeListStringToTypeIdCache = newObj(),\n        typeListStringToTypeIdCacheSize = 0,\n\n    /* Various mappings */\n    typeToValueMapping = newObj(),\n        aliasToTypeMapping = newObj(),\n        typeToAliasMapping = newObj(),\n        nameToAliasMapping = newObj(),\n        objToStringToNameMapping = newObj(),\n        optionsModule = newObj(),\n        extensionsModule = newObj();\n    /*\n     * ----------------\n     * MODULE FUNCTIONS\n     * ---------------- \n     */\n\n    function typeOf(item) {\n      var typeName = typeof item === 'object' || typeof item === 'function' ? objToStringToNameMapping[objToString.call(item)] || objToString.call(item).match(OBJECT_CLASS_REGEX)[1].toLowerCase() : typeof item;\n\n      if (typeName === 'number' && isNaN(item)) {\n        typeName = TYPEOF_NAN;\n      }\n\n      return isAliasMode ? nameToAliasMapping[typeName] || typeName : typeName;\n    }\n\n    function type(item) {\n      var typeName = item === null ? TYPEOF_NULL : typeof item === 'object' || typeof item === 'function' ? objToStringToNameMapping[objToString.call(item)] || 'object' : typeof item;\n\n      if (typeName === 'number' && isNaN(item)) {\n        typeName = TYPEOF_NAN;\n      }\n\n      return isAliasMode ? nameToAliasMapping[typeName] || typeName : typeName;\n    }\n    /**\n     * Checks whether the specified item is of any of the specified types.\n     */\n\n\n    function isType(item, types) {\n      var compositeType = typeof types === 'number' ? ANY_TYPE & types : typeof types === 'string' && typeListStringToTypeIdCache[types] !== undefined ? typeListStringToTypeIdCache[types] : getCompositeType(types, item);\n      return typeof compositeType === 'function' || // Item is a specified instance type\n      typeof compositeType === 'object' || // Item is a specified custom type\n      !!getBaseType(item, compositeType);\n    }\n    /**\n     * Return the first of the types, if any, matches the type of the item.\n     */\n\n\n    function which(item, types) {\n      types = typeof types === 'string' ? types.split(typeDelimiterRegExp) : !isArray(types) ? [types] : types;\n      var typeCount = types.length,\n          typeIndex;\n\n      for (typeIndex = 0; typeIndex < typeCount; typeIndex++) {\n        if (isType(item, types[typeIndex])) {\n          return types[typeIndex];\n        }\n      }\n\n      return typeToAliasMapping[NONE_TYPE];\n    }\n    /**\n     * Returns the most specific available type for the specified item. \n     */\n\n\n    function xtype(item) {\n      return typeToAliasMapping[getBaseType(item)];\n    }\n    /**\n     * Gets the derived type of the specified item.\n     * @param eligibleTypesComposite The derived type \n     * composite whose member types filter the result.\n     */\n\n\n    function getBaseType(item, eligibleTypesComposite) {\n      var itemSimpleType = aliasToTypeMapping[type(item)] || NONE_TYPE;\n\n      if ((itemSimpleType & DERIVED_TYPE) === 0) {\n        // Not a derived type, so return eligible type immediately\n        return itemSimpleType & (eligibleTypesComposite !== undefined ? ANY_TYPE & eligibleTypesComposite : ANY_TYPE);\n      }\n\n      var derivedTypeComposite = eligibleTypesComposite !== undefined ? DERIVED_TYPE & eligibleTypesComposite : DERIVED_TYPE;\n\n      if (derivedTypeComposite === 0) {\n        // No matching eligible derived type\n        return 0;\n      }\n\n      var strLength, // strings\n      strTrimLength, arrElemCount, // arrays\n      objPropCount; // objects\n      // Determine base type from derived type\n\n      switch (itemSimpleType) {\n        case STRING:\n          return (strLength = item.length) && (strTrimLength = item.trim().length) && false ? 0 // evaluate multi-use values only once\n          : EMPTY_STRING & derivedTypeComposite && strLength === 0 ? EMPTY_STRING : WHITESPACE & derivedTypeComposite && strLength > 0 && strTrimLength === 0 ? WHITESPACE : MULTI_CHAR_STRING & derivedTypeComposite && strTrimLength > 1 ? MULTI_CHAR_STRING : SINGLE_CHAR_STRING & derivedTypeComposite && strTrimLength === 1 ? SINGLE_CHAR_STRING : 0;\n\n        case NUMBER:\n          // Use non-strict equality to handle primitive and boxed zero number\n          return ZERO & derivedTypeComposite && item == 0 ? ZERO // jshint ignore:line                        \n          : NON_INFINITE_NUMBER & derivedTypeComposite && isFinite(item) ? INTEGER & derivedTypeComposite && item % 1 === 0 ? POSITIVE_INTEGER & derivedTypeComposite && item > 0 ? POSITIVE_INTEGER : NEGATIVE_INTEGER & derivedTypeComposite && item < 0 ? NEGATIVE_INTEGER : 0 : FLOAT & derivedTypeComposite && item % 1 !== 0 ? POSITIVE_FLOAT & derivedTypeComposite && item > 0 ? POSITIVE_FLOAT : NEGATIVE_FLOAT & derivedTypeComposite && item < 0 ? NEGATIVE_FLOAT : 0 : 0 : INFINITE_NUMBER & derivedTypeComposite && !isFinite(item) ? POSITIVE_INFINITY & derivedTypeComposite && item > 0 ? POSITIVE_INFINITY : NEGATIVE_INFINITY & derivedTypeComposite && item < 0 ? NEGATIVE_INFINITY : 0 : 0;\n\n        case BOOLEAN:\n          // Use non-strict equality to handle primitive and boxed booleans\n          return TRUE & derivedTypeComposite && item == true ? TRUE // jshint ignore:line\n          : FALSE & derivedTypeComposite && item == false ? FALSE // jshint ignore:line\n          : 0;\n\n        case ARRAY:\n          return (arrElemCount = item.length) && false ? 0 // evaluate multi-use values only once\n          : EMPTY_ARRAY & derivedTypeComposite && arrElemCount === 0 ? EMPTY_ARRAY : SINGLE_ELEM_ARRAY & derivedTypeComposite && arrElemCount === 1 ? SINGLE_ELEM_ARRAY : MULTI_ELEM_ARRAY & derivedTypeComposite && arrElemCount > 1 ? MULTI_ELEM_ARRAY : 0;\n\n        case OBJECT:\n          return (objPropCount = objKeys(item).length) && false ? 0 // evaluate multi-use values only once\n          : EMPTY_OBJECT & derivedTypeComposite && objPropCount === 0 ? EMPTY_OBJECT : SINGLE_PROP_OBJECT & derivedTypeComposite && objPropCount === 1 ? SINGLE_PROP_OBJECT : MULTI_PROP_OBJECT & derivedTypeComposite && objPropCount > 1 ? MULTI_PROP_OBJECT : 0;\n      }\n\n      return 0;\n    }\n    /**\n     * Gets the composite type consisting of the specified types.\n     */\n\n\n    function getCompositeType(types, item) {\n      var typeString;\n\n      if (typeof types === 'string') {\n        // uncached string\n        typeString = types;\n        types = types.split(typeDelimiterRegExp);\n      } else if (!isArray(types)) {\n        types = [types];\n      }\n\n      var compositeType = 0,\n          requestedType,\n          typeDefinition;\n\n      for (var typeIndex = 0, typeCount = types.length; typeIndex < typeCount; typeIndex++) {\n        requestedType = types[typeIndex];\n        typeDefinition = typeof requestedType === 'string' ? aliasToTypeMapping[requestedType] || 0 : typeof requestedType === 'object' ? // Support for unregistered custom-validated type if validator function field present in obj\n        requestedType !== null && typeof requestedType.validator === 'function' ? requestedType : 0 : requestedType || 0;\n\n        if (typeof typeDefinition === 'number') {\n          compositeType = compositeType | ANY_TYPE & typeDefinition;\n        } else if (typeof typeDefinition === 'function' && item instanceof typeDefinition) {\n          return typeDefinition;\n        } else if (typeof typeDefinition === 'object' && typeDefinition.validator(item) === true) {\n          // No further need to null-check type definition\n          return typeDefinition;\n        }\n      }\n\n      if (compositeType && typeString && typeListStringToTypeIdCacheSize <= MAX_REQUEST_TYPE_CACHE_SIZE) {\n        typeListStringToTypeIdCache[typeString] = compositeType;\n        typeListStringToTypeIdCacheSize++;\n      }\n\n      return compositeType;\n    }\n    /*\n     * ----------------\n     * HELPER FUNCTIONS\n     * ----------------\n     */\n\n    /**\n     * Builds an alias map using data in supplied value and alias mappings.\n     */\n\n\n    function buildAliasMappings() {\n      var typeAliasMapping = newObj(),\n          aliasTypeMapping = newObj(),\n          nameAliasMapping = newObj(),\n          usedAliases = newObj();\n      objKeys(typeToValueMapping).forEach(function (typeName) {\n        var typeValue = typeToValueMapping[typeName];\n        var aliasName = activeNameScheme ? activeNameScheme[typeName] : typeName;\n        aliasName = typeof aliasName === 'string' && aliasName.length > 0 ? aliasName : typeName;\n\n        if (aliasName in usedAliases) {\n          throwError('Type name conflict: \"' + aliasName + '\" is aliased to \"' + typeName + '\" and \"' + usedAliases[aliasName] + '\"');\n        }\n\n        if (typeof typeValue === 'number') {\n          typeAliasMapping[typeValue] = aliasName; // Type Ids used only for built-in simple and extended types (with numeric Ids) \n        }\n\n        aliasTypeMapping[aliasName] = typeValue;\n        nameAliasMapping[typeName] = aliasName;\n        usedAliases[aliasName] = typeName;\n      });\n      typeToAliasMapping = typeAliasMapping;\n      aliasToTypeMapping = aliasTypeMapping;\n      nameToAliasMapping = nameAliasMapping;\n      isAliasMode = !!activeNameScheme;\n      clearTypeListStringCache();\n    }\n\n    function defineInterfacePackagesAndMethods(hostObj) {\n      hostObj.not = newObj();\n      hostObj.any = newObj();\n      hostObj.all = newObj();\n      hostObj.some = newObj();\n      hostObj.none = newObj();\n\n      hostObj.not.is = function (value, types) {\n        return !isType(value, types);\n      };\n\n      hostObj.any.is = getInterfaceFunction(isType, true, true, undefined, true);\n      hostObj.all.is = getInterfaceFunction(isType, true, undefined, true, false);\n      hostObj.some.is = getInterfaceFunction(isType, true, true, true, true);\n      hostObj.none.is = getInterfaceFunction(isType, true, true, undefined, false);\n    }\n    /**\n     * Defines the typeId property and associated type check\n     * and interface methods for the specified type.\n     */\n\n\n    function defineType(typeName, typeDefinition, hostObj) {\n      if (typeName in typeToValueMapping) {\n        throwError('Cannot define type \\'' + typeName + '\\' - type already defined');\n      }\n\n      typeToValueMapping[typeName] = typeDefinition;\n\n      if (typeof typeDefinition === 'number') {\n        Object.defineProperty(hostObj, typeName.toUpperCase(), {\n          value: typeToValueMapping[typeName],\n          enumerable: true,\n          writable: false,\n          configurable: false\n        });\n      }\n\n      var typeMethodName = getTypeMethodName(typeName);\n\n      var typeCheckFunction = function (item) {\n        return isType(item, typeToValueMapping[typeName] || typeName);\n      };\n\n      hostObj[typeMethodName] = typeCheckFunction;\n\n      hostObj.not[typeMethodName] = function (value) {\n        return !typeCheckFunction(value);\n      };\n\n      hostObj.any[typeMethodName] = getInterfaceFunction(typeCheckFunction, false, true, undefined, true);\n      hostObj.all[typeMethodName] = getInterfaceFunction(typeCheckFunction, false, undefined, true, false);\n      hostObj.some[typeMethodName] = getInterfaceFunction(typeCheckFunction, false, true, true, true);\n      hostObj.none[typeMethodName] = getInterfaceFunction(typeCheckFunction, false, true, undefined, false);\n    }\n    /**\n     * Clears the memoization cache of type list strings used in requests.\n     */\n\n\n    function clearTypeListStringCache() {\n      typeListStringToTypeIdCache = newObj();\n      typeListStringToTypeIdCacheSize = 0;\n    }\n    /**\n     * Gets the name to be used for the type-matching \n     * method name for the specified type.\n     */\n\n\n    function getTypeMethodName(typeName) {\n      var capitalizedTypeName = typeName.toLowerCase().replace(/(^|_)(.)/g, function (match, camelPrefix, camelChar) {\n        return camelChar.toUpperCase();\n      });\n      return 'is' + capitalizedTypeName;\n    }\n    /**\n     * Creates an interface function using the specified parameters.\n     */\n\n\n    function getInterfaceFunction(delegateFunction, withTypes, trueCondition, falseCondition, terminationResult) {\n      return function (values, types) {\n        values = !withTypes && arguments.length > 1 ? arraySlice.call(arguments) : isArray(values) ? values : [values];\n        var trueResult = false,\n            falseResult = false,\n            valueIndex;\n\n        for (valueIndex = 0; valueIndex < values.length; valueIndex++) {\n          if (delegateFunction(values[valueIndex], types)) {\n            trueResult = true;\n          } else {\n            falseResult = true;\n          }\n\n          if ((trueCondition === undefined || trueResult === trueCondition) && (falseCondition === undefined || falseResult === falseCondition)) {\n            return terminationResult;\n          }\n        }\n\n        return !terminationResult;\n      };\n    }\n\n    function capitalize(string) {\n      return string.charAt(0).toUpperCase() + string.slice(1);\n    }\n\n    function throwError(message) {\n      throw new Error(LIB_NAME + ': ' + message);\n    }\n    /*\n     * -----------------\n     * EXTENSIONS MODULE\n     * -----------------\n     */\n\n\n    function registerNameScheme(schemeName, schemeAliases) {\n      if (typeof schemeName !== 'string' || schemeName.trim().length === 0 || typeof schemeAliases !== 'object') {\n        return;\n      }\n\n      var trimSchemeName = schemeName.trim(),\n          existingScheme = nameSchemes[trimSchemeName],\n          newScheme = newObj();\n      objKeys(schemeAliases).forEach(function (typeName) {\n        newScheme[typeName] = schemeAliases[typeName];\n      });\n      nameSchemes[trimSchemeName] = newScheme;\n      return existingScheme;\n    }\n\n    extensionsModule.registerNameScheme = registerNameScheme;\n    /*\n     * --------------\n     * OPTIONS MODULE\n     * --------------\n     */\n\n    function setDelimiterPattern(delimiterPattern) {\n      delimiterPattern = delimiterPattern === null || delimiterPattern === undefined || delimiterPattern === '' ? TYPE_DELIMITER_DEFAULT_PATTERN : delimiterPattern;\n\n      if (typeof delimiterPattern !== 'string') {\n        return;\n      }\n\n      delimiterPattern = '[ ]*' + delimiterPattern + '[ ]*';\n\n      if (typeDelimiterRegExp && delimiterPattern === typeDelimiterRegExp.source) {\n        return;\n      }\n\n      typeDelimiterRegExp = new RegExp(delimiterPattern, 'g');\n      clearTypeListStringCache();\n    }\n\n    function setNameScheme(nameScheme) {\n      if (nameScheme === undefined || nameScheme === null || nameScheme === NAME_SCHEME_DEFAULT_OPTION_VALUE) {\n        nameScheme = null;\n      } else if (typeof nameScheme === 'string' && nameScheme in nameSchemes) {\n        nameScheme = nameSchemes[nameScheme];\n      }\n\n      if (nameScheme !== null && typeof nameScheme !== 'object') {\n        throwError('Unknown name scheme \"' + nameScheme + '\"');\n      }\n\n      activeNameScheme = nameScheme;\n      doRefresh();\n    }\n\n    function setOptions(options) {\n      if (typeof options !== 'object') {\n        return;\n      }\n\n      objKeys(options).forEach(function (optionName) {\n        var optionMethod = optionsModule['set' + capitalize(optionName)];\n\n        if (typeof optionMethod === 'function') {\n          optionMethod(options[optionName]);\n        }\n      });\n    }\n\n    optionsModule.setDelimiterPattern = setDelimiterPattern;\n    optionsModule.setNameScheme = setNameScheme;\n    optionsModule.set = setOptions;\n    /*\n     * --------------\n     * MODULE REFRESH\n     * --------------\n     */\n\n    function coreModuleRefreshHandler() {\n      buildAliasMappings();\n    }\n\n    function doRefresh() {\n      coreModuleRefreshHandler();\n      doModuleTriggeredRefresh(coreModuleRefreshHandler);\n    }\n\n    var doModuleTriggeredRefresh = function () {\n      var handlersRequestingModuleRefresh = [],\n          isModuleRefreshing = false,\n          isModuleRefreshRequested = false;\n\n      function refreshExtensions(requestingHandlers) {\n        moduleRefreshHandlers.forEach(function (handler) {\n          /*\n           * Don't invoke handlers belonging to extensions \n           * that requested the current refresh.\n           */\n          if (requestingHandlers.indexOf(handler) < 0) {\n            handler.call();\n          }\n        });\n      }\n      /*\n       * Handles extensions' refresh requests by bunching all refresh \n       * requests made during an active refresh into a single subsequent\n       * refresh operation performed on completion of the active refresh.\n       * Also, when the subsequent refresh is processed, excludes handlers \n       * of all the extensions which requested the refresh, in order to \n       * prevent potential cyclic refresh loops in poorly implemented \n       * extensions which may trigger new refreshes while responding to \n       * refresh requests originated by themselves.\n       */\n\n\n      return function (requestingHandler) {\n        isModuleRefreshRequested = true;\n\n        if (requestingHandler) {\n          handlersRequestingModuleRefresh.push(requestingHandler);\n        }\n\n        if (isModuleRefreshing) {\n          return;\n        }\n\n        isModuleRefreshing = true;\n\n        while (isModuleRefreshRequested) {\n          isModuleRefreshRequested = false;\n          refreshExtensions(handlersRequestingModuleRefresh);\n        }\n\n        handlersRequestingModuleRefresh = [];\n        isModuleRefreshing = false;\n      };\n    }();\n    /*\n     * ----------------\n     * ADDON EXTENSIONS\n     * ----------------\n     */\n\n\n    function registerExtensions(extensions, xtypeModule) {\n      (isArray(extensions) ? extensions : [extensions]).forEach(function (extension) {\n        if (!extension || extension.type !== 'xtypejs' || typeof extension.init !== 'function') {\n          throwError('Invalid extension - \"type\" property must be \"xtypejs\" and \"init\" property must be a function');\n        }\n\n        registeredExtensions.push(extension.init);\n        applyExtension(extension.init, xtypeModule);\n      });\n    }\n\n    function applyExtension(extensionInit, hostModule) {\n      var moduleRefreshHandler = null,\n          extensionInterface = {\n        getTypeDefinitions: function () {\n          return typeToValueMapping;\n        },\n        getNameSchemes: function () {\n          return nameSchemes;\n        },\n        getActiveNameScheme: function () {\n          return activeNameScheme;\n        },\n        defineType: function (typeName, typeValue) {\n          defineType(typeName, typeValue, hostModule);\n        },\n        refresh: function () {\n          doModuleTriggeredRefresh(moduleRefreshHandler);\n        },\n        setRefreshHandler: function (handler) {\n          var existingHandlerIndex = moduleRefreshHandlers.indexOf(moduleRefreshHandler || handler);\n\n          if (existingHandlerIndex > -1) {\n            moduleRefreshHandlers.splice(existingHandlerIndex, 1);\n          }\n\n          if (typeof handler === 'function') {\n            moduleRefreshHandlers.push(handler);\n            moduleRefreshHandler = handler;\n          }\n        }\n      };\n      extensionInit.call(extensionInterface, hostModule);\n    }\n    /*\n     * ---------------------\n     * MODULE SETUP / EXPORT\n     * ---------------------\n     */\n\n\n    function init() {\n      var moduleExport = xtype;\n      setDelimiterPattern(TYPE_DELIMITER_DEFAULT_PATTERN);\n      ['Boolean', 'Number', 'String', 'Symbol', 'Function', 'Array', 'Date', 'RegExp', 'Object', 'Error'].forEach(function (objectType) {\n        objToStringToNameMapping['[object ' + objectType + ']'] = objectType.toLowerCase();\n      });\n      defineInterfacePackagesAndMethods(moduleExport);\n      objKeys(TYPE_VALUE_MAPPING).forEach(function (typeName) {\n        defineType(typeName, TYPE_VALUE_MAPPING[typeName], moduleExport);\n      });\n      buildAliasMappings();\n      moduleRefreshHandlers.push(coreModuleRefreshHandler);\n      Object.defineProperty(moduleExport, 'VERSION', {\n        value: /\\s*{{[^}]*}}\\s*/g.test(LIB_VERSION) ? 'unspecified' : LIB_VERSION,\n        enumerable: true,\n        writable: false,\n        configurable: false\n      });\n      /*\n       * Attach API methods to module export\n       */\n\n      moduleExport.type = type;\n      moduleExport.typeOf = typeOf;\n      moduleExport.which = which;\n      moduleExport.is = isType;\n      moduleExport.ext = extensionsModule;\n      moduleExport.options = optionsModule;\n      moduleExport.newInstance = newModuleInstance;\n\n      moduleExport.ext.registerExtension = function (extensions) {\n        extensions = arguments.length > 1 ? arraySlice.call(arguments) : extensions;\n        registerExtensions(extensions, moduleExport);\n      };\n      /*\n       * Apply registered extensions on new instance\n       */\n\n\n      registeredExtensions.forEach(function (extension) {\n        applyExtension(extension, moduleExport);\n      });\n      return moduleExport;\n    }\n\n    return init();\n  }\n  /*\n   * Export module\n   */\n\n\n  var moduleExport = newModuleInstance();\n\n  if (typeof define === 'function' && define.amd) {\n    define([], function () {\n      return moduleExport;\n    });\n  } else if (typeof module === 'object' && module.exports) {\n    module.exports = moduleExport;\n  } else {\n    moduleExport.noConflict = function (previouslyDefinedValue) {\n      return function () {\n        root[LIB_NAME] = previouslyDefinedValue;\n        delete moduleExport.noConflict;\n        return moduleExport;\n      };\n    }(root[LIB_NAME]);\n\n    root[LIB_NAME] = moduleExport;\n  }\n})(this);","map":{"version":3,"sources":["/Users/kzjouf/Desktop/project/sc-dapp/node_modules/xtypejs/dist/xtype.js"],"names":["root","undefined","LIB_NAME","LIB_VERSION","TYPE_DELIMITER_DEFAULT_PATTERN","NAME_SCHEME_DEFAULT_OPTION_VALUE","OBJECT_CLASS_REGEX","MAX_REQUEST_TYPE_CACHE_SIZE","registeredExtensions","Array","constructor","isArray","arrayPush","prototype","push","arraySlice","slice","Object","objCreate","create","objKeys","keys","objToString","toString","newObj","NONE_TYPE","NULL","UNDEFINED","NAN","TRUE","FALSE","EMPTY_STRING","WHITESPACE","SINGLE_CHAR_STRING","MULTI_CHAR_STRING","ZERO","POSITIVE_INTEGER","POSITIVE_FLOAT","POSITIVE_INFINITY","NEGATIVE_INTEGER","NEGATIVE_FLOAT","NEGATIVE_INFINITY","EMPTY_ARRAY","SINGLE_ELEM_ARRAY","MULTI_ELEM_ARRAY","EMPTY_OBJECT","SINGLE_PROP_OBJECT","MULTI_PROP_OBJECT","SYMBOL","FUNCTION","DATE","ERROR","REGEXP","BOOLEAN","STRING","NUMBER","ARRAY","OBJECT","BLANK_STRING","NON_EMPTY_STRING","NON_BLANK_STRING","FLOAT","INTEGER","INFINITE_NUMBER","NON_INFINITE_NUMBER","POSITIVE_NUMBER","NEGATIVE_NUMBER","NON_ZERO_NUMBER","NON_NEGATIVE_NUMBER","NON_POSITIVE_NUMBER","NON_EMPTY_OBJECT","NON_EMPTY_ARRAY","NOTHING","PRIMITIVE","ANY_TYPE","DERIVED_TYPE","TYPE_VALUE_MAPPING","nan","boolean","string","empty_string","whitespace","single_char_string","multi_char_string","blank_string","non_empty_string","non_blank_string","number","zero","positive_integer","positive_float","positive_infinity","negative_integer","negative_float","negative_infinity","integer","float","infinite_number","positive_number","negative_number","non_infinite_number","non_positive_number","non_negative_number","non_zero_number","array","empty_array","single_elem_array","multi_elem_array","non_empty_array","object","empty_object","single_prop_object","multi_prop_object","non_empty_object","symbol","date","error","regexp","nothing","primitive","any","none","TYPEOF_NULL","TYPEOF_NAN","newModuleInstance","moduleRefreshHandlers","nameSchemes","activeNameScheme","isAliasMode","typeDelimiterRegExp","typeListStringToTypeIdCache","typeListStringToTypeIdCacheSize","typeToValueMapping","aliasToTypeMapping","typeToAliasMapping","nameToAliasMapping","objToStringToNameMapping","optionsModule","extensionsModule","typeOf","item","typeName","call","match","toLowerCase","isNaN","type","isType","types","compositeType","getCompositeType","getBaseType","which","split","typeCount","length","typeIndex","xtype","eligibleTypesComposite","itemSimpleType","derivedTypeComposite","strLength","strTrimLength","arrElemCount","objPropCount","trim","isFinite","typeString","requestedType","typeDefinition","validator","buildAliasMappings","typeAliasMapping","aliasTypeMapping","nameAliasMapping","usedAliases","forEach","typeValue","aliasName","throwError","clearTypeListStringCache","defineInterfacePackagesAndMethods","hostObj","not","all","some","is","value","getInterfaceFunction","defineType","defineProperty","toUpperCase","enumerable","writable","configurable","typeMethodName","getTypeMethodName","typeCheckFunction","capitalizedTypeName","replace","camelPrefix","camelChar","delegateFunction","withTypes","trueCondition","falseCondition","terminationResult","values","arguments","trueResult","falseResult","valueIndex","capitalize","charAt","message","Error","registerNameScheme","schemeName","schemeAliases","trimSchemeName","existingScheme","newScheme","setDelimiterPattern","delimiterPattern","source","RegExp","setNameScheme","nameScheme","doRefresh","setOptions","options","optionName","optionMethod","set","coreModuleRefreshHandler","doModuleTriggeredRefresh","handlersRequestingModuleRefresh","isModuleRefreshing","isModuleRefreshRequested","refreshExtensions","requestingHandlers","handler","indexOf","requestingHandler","registerExtensions","extensions","xtypeModule","extension","init","applyExtension","extensionInit","hostModule","moduleRefreshHandler","extensionInterface","getTypeDefinitions","getNameSchemes","getActiveNameScheme","refresh","setRefreshHandler","existingHandlerIndex","splice","moduleExport","objectType","test","ext","newInstance","registerExtension","define","amd","module","exports","noConflict","previouslyDefinedValue"],"mappings":"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","sourcesContent":["/** @license | xtypejs v0.7.1 | (c) 2015, Lucas Ononiwu | MIT license, xtype.js.org/license.txt\n */\n\n/**\n * The MIT License (MIT)\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n \n(function(root, undefined) {\n    \n    'use strict';\n\n    /*\n    * --------------\n    * MODULE GLOBALS\n    * --------------\n    */\n    \n    var LIB_NAME = 'xtype',\n        LIB_VERSION = '0.7.1',\n        \n        TYPE_DELIMITER_DEFAULT_PATTERN = '[|, ]',\n        NAME_SCHEME_DEFAULT_OPTION_VALUE = 'default',\n        OBJECT_CLASS_REGEX = /^\\[object\\s(.*)\\]$/,\n        MAX_REQUEST_TYPE_CACHE_SIZE = 250,\n        \n        /* --- Extensions and Module Refresh --- */\n\n        registeredExtensions = [],\n        \n        /* --- Localized function references --- */\n\n        Array = ([]).constructor || Array,\n        isArray = Array.isArray,\n        arrayPush = Array.prototype.push,\n        arraySlice = Array.prototype.slice,\n        \n        Object = ({}).constructor || Object,\n        objCreate = Object.create,\n        objKeys = Object.keys,\n        objToString = Object.prototype.toString,\n\n        newObj = function() {\n            return objCreate(null);\n        },\n        \n        /*\n        * -----------\n        * BASE TYPES \n        * -----------\n        */\n        \n        NONE_TYPE           = 0,                // No type\n        \n        /*  Nothing types  */\n        \n        NULL                = (1 << 0),\n        UNDEFINED           = (1 << 1),\n        NAN                 = (1 << 2),\n        \n        /* Boolean */\n        \n        TRUE                = (1 << 3),\n        FALSE               = (1 << 4),\n        \n        /*  String  */\n        \n        EMPTY_STRING        = (1 << 5),        // String with zero characters.\n        WHITESPACE          = (1 << 6),        // String with one or more of only whitespace characters.\n        SINGLE_CHAR_STRING  = (1 << 7),        // String with exactly one non-whitespace and zero or more whitespace characters.\n        MULTI_CHAR_STRING   = (1 << 8),        // String with more than one non-whitespace and zero or more whitespace characters.\n        \n        /* Number */\n        \n        ZERO                = (1 << 9),\n        POSITIVE_INTEGER    = (1 << 10), \n        POSITIVE_FLOAT      = (1 << 11), \n        POSITIVE_INFINITY   = (1 << 12), \n        NEGATIVE_INTEGER    = (1 << 13),\n        NEGATIVE_FLOAT      = (1 << 14),\n        NEGATIVE_INFINITY   = (1 << 15),\n        \n        /* Array */\n        \n        EMPTY_ARRAY         = (1 << 16),\n        SINGLE_ELEM_ARRAY   = (1 << 17), \n        MULTI_ELEM_ARRAY    = (1 << 18),\n        \n        /* Object */\n        \n        EMPTY_OBJECT        = (1 << 19),\n        SINGLE_PROP_OBJECT  = (1 << 20),\n        MULTI_PROP_OBJECT   = (1 << 21),\n        \n        /*  ECMA types  */\n        \n        SYMBOL              = (1 << 22),\n        FUNCTION            = (1 << 23), \n        DATE                = (1 << 24), \n        ERROR               = (1 << 25), \n        REGEXP              = (1 << 26),\n        \n        /*\n        * --------------\n        * DERIVED TYPES \n        * --------------\n        */\n        \n        /*  Derived Simple types  */\n        \n        BOOLEAN             = (TRUE | FALSE), \n        STRING              = (EMPTY_STRING | WHITESPACE | SINGLE_CHAR_STRING | MULTI_CHAR_STRING), \n        NUMBER              = (POSITIVE_INTEGER | POSITIVE_FLOAT | POSITIVE_INFINITY | NEGATIVE_INTEGER | NEGATIVE_FLOAT | NEGATIVE_INFINITY | ZERO),\n        ARRAY               = (EMPTY_ARRAY | SINGLE_ELEM_ARRAY | MULTI_ELEM_ARRAY),\n        OBJECT              = (EMPTY_OBJECT | SINGLE_PROP_OBJECT | MULTI_PROP_OBJECT),\n        \n        /*  Other derived types  */\n        \n        BLANK_STRING        = (EMPTY_STRING | WHITESPACE),\n        NON_EMPTY_STRING    = (WHITESPACE | SINGLE_CHAR_STRING | MULTI_CHAR_STRING),\n        NON_BLANK_STRING    = (SINGLE_CHAR_STRING | MULTI_CHAR_STRING),\n        \n        FLOAT               = (POSITIVE_FLOAT | NEGATIVE_FLOAT),\n        INTEGER             = (POSITIVE_INTEGER | NEGATIVE_INTEGER | ZERO),\n        INFINITE_NUMBER     = (POSITIVE_INFINITY | NEGATIVE_INFINITY),\n        NON_INFINITE_NUMBER = (INTEGER | FLOAT),\n        POSITIVE_NUMBER     = (POSITIVE_INTEGER | POSITIVE_FLOAT | POSITIVE_INFINITY),\n        NEGATIVE_NUMBER     = (NEGATIVE_INTEGER | NEGATIVE_FLOAT | NEGATIVE_INFINITY),\n        NON_ZERO_NUMBER     = (POSITIVE_NUMBER | NEGATIVE_NUMBER),\n        NON_NEGATIVE_NUMBER = (POSITIVE_NUMBER | ZERO),\n        NON_POSITIVE_NUMBER = (NEGATIVE_NUMBER | ZERO),\n        \n        NON_EMPTY_OBJECT    = (SINGLE_PROP_OBJECT | MULTI_PROP_OBJECT),\n        NON_EMPTY_ARRAY     = (SINGLE_ELEM_ARRAY | MULTI_ELEM_ARRAY),\n        \n        NOTHING             = (NULL | UNDEFINED),\n        PRIMITIVE           = (STRING | NUMBER | BOOLEAN | SYMBOL),\n        \n        // Composite of all base types (effectively all derived and non-derived types)\n        ANY_TYPE = (\n                NULL | UNDEFINED | NAN |\n                SYMBOL | FUNCTION | DATE | ERROR | REGEXP |\n                TRUE | FALSE |\n                EMPTY_STRING | WHITESPACE | SINGLE_CHAR_STRING | MULTI_CHAR_STRING |\n                ZERO | POSITIVE_INTEGER | POSITIVE_FLOAT | POSITIVE_INFINITY | NEGATIVE_INTEGER | NEGATIVE_FLOAT | NEGATIVE_INFINITY |\n                EMPTY_ARRAY | SINGLE_ELEM_ARRAY | MULTI_ELEM_ARRAY | \n                EMPTY_OBJECT | SINGLE_PROP_OBJECT | MULTI_PROP_OBJECT),\n        \n        // Composite of all derived types (Internal)\n        DERIVED_TYPE = (BOOLEAN | STRING | NUMBER | ARRAY | OBJECT);\n    \n    var TYPE_VALUE_MAPPING = {\n            \n            // -- Absent --\n            'null': NULL,\n            'undefined': UNDEFINED,\n            nan: NAN,\n            \n            // -- Boolean --\n            boolean: BOOLEAN, \n            'true': TRUE,\n            'false': FALSE,\n            \n            // -- String --\n            string: STRING, \n            empty_string: EMPTY_STRING,\n            whitespace: WHITESPACE,\n            single_char_string: SINGLE_CHAR_STRING,\n            multi_char_string: MULTI_CHAR_STRING,\n            // Composite\n            blank_string: BLANK_STRING,\n            non_empty_string: NON_EMPTY_STRING,\n            non_blank_string: NON_BLANK_STRING,\n            \n            // -- Number --\n            number: NUMBER,\n            zero: ZERO,\n            positive_integer: POSITIVE_INTEGER, \n            positive_float: POSITIVE_FLOAT, \n            positive_infinity: POSITIVE_INFINITY, \n            negative_integer: NEGATIVE_INTEGER,\n            negative_float: NEGATIVE_FLOAT,\n            negative_infinity: NEGATIVE_INFINITY, \n            // Composite\n            integer: INTEGER,\n            float: FLOAT,\n            infinite_number: INFINITE_NUMBER,\n            positive_number: POSITIVE_NUMBER, \n            negative_number: NEGATIVE_NUMBER,\n            non_infinite_number: NON_INFINITE_NUMBER,\n            non_positive_number: NON_POSITIVE_NUMBER,\n            non_negative_number: NON_NEGATIVE_NUMBER,\n            non_zero_number: NON_ZERO_NUMBER,\n            \n            // -- Array --\n            array: ARRAY, \n            empty_array: EMPTY_ARRAY, \n            single_elem_array: SINGLE_ELEM_ARRAY,\n            multi_elem_array: MULTI_ELEM_ARRAY,\n            non_empty_array: NON_EMPTY_ARRAY,\n            \n            // -- Object --\n            object: OBJECT,\n            empty_object: EMPTY_OBJECT,\n            single_prop_object: SINGLE_PROP_OBJECT,\n            multi_prop_object: MULTI_PROP_OBJECT,\n            non_empty_object: NON_EMPTY_OBJECT,\n            \n            // -- Other --\n            symbol: SYMBOL,\n            date: DATE, \n            error: ERROR, \n            regexp: REGEXP,             \n            'function': FUNCTION, \n            \n            nothing: NOTHING,            \n            primitive: PRIMITIVE,\n            any: ANY_TYPE,\n            none: NONE_TYPE\n    };\n\n    /* Custome Typeof */\n    \n    var TYPEOF_NULL = 'null',\n        TYPEOF_NAN = 'nan';\n\n\n    /*\n    * --------------\n    * MODULE FACTORY\n    * --------------\n    */\n    \n    function newModuleInstance() {\n        \n        var moduleRefreshHandlers = [],\n            nameSchemes = newObj(),\n            activeNameScheme,\n            isAliasMode = false,\n            typeDelimiterRegExp,\n            \n            /* Type list string memoization cache */\n            typeListStringToTypeIdCache = newObj(),\n            typeListStringToTypeIdCacheSize = 0,\n            \n            /* Various mappings */\n            typeToValueMapping = newObj(),\n            aliasToTypeMapping = newObj(),\n            typeToAliasMapping = newObj(),\n            nameToAliasMapping = newObj(),\n            objToStringToNameMapping = newObj(),\n        \n            optionsModule = newObj(),\n            extensionsModule = newObj();\n        \n        /*\n         * ----------------\n         * MODULE FUNCTIONS\n         * ---------------- \n         */\n        \n        function typeOf(item) {\n            var typeName = (typeof item === 'object' || typeof item === 'function') ?  \n                            (objToStringToNameMapping[objToString.call(item)] || \n                            objToString.call(item).match(OBJECT_CLASS_REGEX)[1].toLowerCase())\n                    : typeof item;\n            \n            if (typeName === 'number' && isNaN(item)) {\n                typeName = TYPEOF_NAN;\n            }\n            \n            return (isAliasMode ? (nameToAliasMapping[typeName] || typeName) : typeName);\n        }\n        \n        function type(item) {\n            var typeName = (item === null) ? TYPEOF_NULL\n                    : (typeof item === 'object' || typeof item === 'function') ?\n                            (objToStringToNameMapping[objToString.call(item)] || 'object')\n                    : typeof item;\n            \n            if (typeName === 'number' && isNaN(item)) {\n                typeName = TYPEOF_NAN;\n            }\n            \n            return (isAliasMode ? (nameToAliasMapping[typeName] || typeName) : typeName);\n        }\n        \n        /**\n         * Checks whether the specified item is of any of the specified types.\n         */\n        function isType(item, types) {\n            var compositeType = (typeof types === 'number') ? (ANY_TYPE & types)\n                    : (typeof types === 'string' && typeListStringToTypeIdCache[types] !== undefined) ?\n                            typeListStringToTypeIdCache[types]\n                    : getCompositeType(types, item);\n            \n            return (typeof compositeType === 'function') ||     // Item is a specified instance type\n                    (typeof compositeType === 'object') ||      // Item is a specified custom type\n                    !!(getBaseType(item, compositeType));\n        }\n    \n        /**\n         * Return the first of the types, if any, matches the type of the item.\n         */\n        function which(item, types) {\n            types = (typeof types === 'string') ? types.split(typeDelimiterRegExp)\n                    : (!isArray(types) ? [types]\n                    : types);\n            \n            var typeCount = types.length,\n                typeIndex;\n            \n            for (typeIndex = 0; typeIndex < typeCount; typeIndex++) {\n                if (isType(item, types[typeIndex])) {\n                    return types[typeIndex];\n                }\n            }\n            return typeToAliasMapping[NONE_TYPE];\n        }\n        \n        /**\n         * Returns the most specific available type for the specified item. \n         */\n        function xtype(item) {\n            return typeToAliasMapping[getBaseType(item)];\n        }\n    \n        /**\n         * Gets the derived type of the specified item.\n         * @param eligibleTypesComposite The derived type \n         * composite whose member types filter the result.\n         */\n        function getBaseType(item, eligibleTypesComposite) {\n            var itemSimpleType = (aliasToTypeMapping[type(item)] || NONE_TYPE);\n            \n            if ((itemSimpleType & DERIVED_TYPE) === 0) {\n                // Not a derived type, so return eligible type immediately\n                return (itemSimpleType & (eligibleTypesComposite !== undefined ? \n                        (ANY_TYPE & eligibleTypesComposite) : ANY_TYPE));\n            }\n            \n            var derivedTypeComposite = (eligibleTypesComposite !== undefined ? \n                    (DERIVED_TYPE & eligibleTypesComposite) : DERIVED_TYPE);\n            \n            if (derivedTypeComposite === 0) {\n                // No matching eligible derived type\n                return 0;\n            }\n            \n            var strLength,          // strings\n                strTrimLength,\n                arrElemCount,       // arrays\n                objPropCount;       // objects\n            \n            // Determine base type from derived type\n            switch (itemSimpleType) {\n                \n                case STRING: \n                    return ((strLength = item.length) && (strTrimLength = item.trim().length) && false) ? 0   // evaluate multi-use values only once\n                        : ((EMPTY_STRING & derivedTypeComposite) && strLength === 0) ? EMPTY_STRING\n                        : ((WHITESPACE & derivedTypeComposite) && strLength > 0 && strTrimLength === 0) ? WHITESPACE\n                        : ((MULTI_CHAR_STRING & derivedTypeComposite) && strTrimLength > 1) ? MULTI_CHAR_STRING\n                        : ((SINGLE_CHAR_STRING & derivedTypeComposite) && strTrimLength === 1) ? SINGLE_CHAR_STRING\n                        : 0;\n                \n                case NUMBER:\n                        // Use non-strict equality to handle primitive and boxed zero number\n                    return ((ZERO & derivedTypeComposite) && item == 0) ? ZERO                  // jshint ignore:line                        \n                        : ((NON_INFINITE_NUMBER & derivedTypeComposite) && isFinite(item)) ? (\n                                ((INTEGER & derivedTypeComposite) && (item % 1) === 0) ? (\n                                        ((POSITIVE_INTEGER & derivedTypeComposite) && item > 0) ? POSITIVE_INTEGER\n                                        : ((NEGATIVE_INTEGER & derivedTypeComposite) && item < 0) ? NEGATIVE_INTEGER\n                                        : 0)\n                                : ((FLOAT & derivedTypeComposite) && (item % 1) !== 0) ? (\n                                        ((POSITIVE_FLOAT & derivedTypeComposite) && item > 0) ? POSITIVE_FLOAT\n                                        : ((NEGATIVE_FLOAT & derivedTypeComposite) && item < 0) ? NEGATIVE_FLOAT\n                                        : 0)\n                                : 0)\n                        : ((INFINITE_NUMBER & derivedTypeComposite) && !isFinite(item)) ? (\n                                ((POSITIVE_INFINITY & derivedTypeComposite) && item > 0) ? POSITIVE_INFINITY\n                                : ((NEGATIVE_INFINITY & derivedTypeComposite) && item < 0) ? NEGATIVE_INFINITY\n                                : 0)\n                        : 0;\n                \n                case BOOLEAN:\n                        // Use non-strict equality to handle primitive and boxed booleans\n                    return ((TRUE & derivedTypeComposite) && (item == true)) ? TRUE             // jshint ignore:line\n                        : ((FALSE & derivedTypeComposite) && (item == false)) ? FALSE           // jshint ignore:line\n                        : 0;\n                \n                case ARRAY:\n                    return ((arrElemCount = item.length) && false) ? 0   // evaluate multi-use values only once\n                        : ((EMPTY_ARRAY & derivedTypeComposite) && arrElemCount === 0) ? EMPTY_ARRAY\n                        : ((SINGLE_ELEM_ARRAY & derivedTypeComposite) && arrElemCount === 1) ? SINGLE_ELEM_ARRAY\n                        : ((MULTI_ELEM_ARRAY & derivedTypeComposite) && arrElemCount > 1) ? MULTI_ELEM_ARRAY\n                        : 0;\n                \n                case OBJECT:\n                    return ((objPropCount = objKeys(item).length) && false) ? 0   // evaluate multi-use values only once\n                        : ((EMPTY_OBJECT & derivedTypeComposite) && objPropCount === 0) ? EMPTY_OBJECT\n                        : ((SINGLE_PROP_OBJECT & derivedTypeComposite) && objPropCount === 1) ? SINGLE_PROP_OBJECT\n                        : ((MULTI_PROP_OBJECT & derivedTypeComposite) && objPropCount > 1) ? MULTI_PROP_OBJECT\n                        : 0;\n            }\n            return 0;\n        }\n        \n        /**\n         * Gets the composite type consisting of the specified types.\n         */\n        function getCompositeType(types, item) {\n            var typeString;\n            \n            if (typeof types === 'string') {    // uncached string\n                typeString = types;\n                types = types.split(typeDelimiterRegExp);\n            } else if (!isArray(types)) {\n                types = [types];\n            }\n            \n            var compositeType = 0,\n                requestedType,\n                typeDefinition;\n            \n            for (var typeIndex = 0, typeCount = types.length; typeIndex < typeCount; typeIndex++) {\n                requestedType = types[typeIndex];\n                typeDefinition = (typeof requestedType === 'string') ? (aliasToTypeMapping[requestedType] || 0) \n                        : (typeof requestedType === 'object') ?         // Support for unregistered custom-validated type if validator function field present in obj\n                                (requestedType !== null && typeof requestedType.validator === 'function' ? requestedType : 0)\n                        : (requestedType || 0);\n                \n                if (typeof typeDefinition === 'number') {\n                    compositeType = (compositeType | (ANY_TYPE & typeDefinition));\n                } else if (typeof typeDefinition === 'function' && (item instanceof typeDefinition)) {\n                    return typeDefinition;\n                } else if (typeof typeDefinition === 'object' && typeDefinition.validator(item) === true) {     // No further need to null-check type definition\n                    return typeDefinition;\n                }\n            }\n            \n            if (compositeType && typeString && (typeListStringToTypeIdCacheSize <= MAX_REQUEST_TYPE_CACHE_SIZE)) {\n                typeListStringToTypeIdCache[typeString] = compositeType;\n                typeListStringToTypeIdCacheSize++;\n            }\n            return compositeType;\n        }\n        \n        /*\n         * ----------------\n         * HELPER FUNCTIONS\n         * ----------------\n         */\n\n        /**\n         * Builds an alias map using data in supplied value and alias mappings.\n         */\n        function buildAliasMappings() {\n            var typeAliasMapping = newObj(),\n                aliasTypeMapping = newObj(),\n                nameAliasMapping = newObj(),\n                usedAliases = newObj();\n            \n            objKeys(typeToValueMapping).forEach(function(typeName) {\n                var typeValue = typeToValueMapping[typeName];\n                var aliasName = (activeNameScheme ? activeNameScheme[typeName] : typeName);\n                aliasName = ((typeof aliasName === 'string' && aliasName.length > 0) ? aliasName : typeName);\n                \n                if (aliasName in usedAliases) {\n                    throwError('Type name conflict: \"' + aliasName + '\" is aliased to \"' + \n                            typeName + '\" and \"' + usedAliases[aliasName] + '\"');\n                }\n                if (typeof typeValue === 'number') {\n                    typeAliasMapping[typeValue] = aliasName;     // Type Ids used only for built-in simple and extended types (with numeric Ids) \n                }\n                aliasTypeMapping[aliasName] = typeValue;\n                nameAliasMapping[typeName] = aliasName;\n                \n                usedAliases[aliasName] = typeName;\n            });\n            typeToAliasMapping = typeAliasMapping;\n            aliasToTypeMapping = aliasTypeMapping;\n            nameToAliasMapping = nameAliasMapping;\n            \n            isAliasMode = !!activeNameScheme;\n            clearTypeListStringCache();\n        }\n        \n        function defineInterfacePackagesAndMethods(hostObj) {\n            hostObj.not = newObj();\n            hostObj.any = newObj();\n            hostObj.all = newObj();\n            hostObj.some = newObj();\n            hostObj.none = newObj();\n\n            hostObj.not.is = function(value, types) {\n                return !isType(value, types);\n            };\n\n            hostObj.any.is = getInterfaceFunction(isType, true, true, undefined, true);\n            hostObj.all.is = getInterfaceFunction(isType, true, undefined, true, false);\n            hostObj.some.is = getInterfaceFunction(isType, true, true, true, true);\n            hostObj.none.is = getInterfaceFunction(isType, true, true, undefined, false);\n        }\n        \n        /**\n         * Defines the typeId property and associated type check\n         * and interface methods for the specified type.\n         */\n        function defineType(typeName, typeDefinition, hostObj) {\n            if (typeName in typeToValueMapping) {\n                throwError('Cannot define type \\'' + typeName + '\\' - type already defined');\n            }\n\n            typeToValueMapping[typeName] = typeDefinition;\n            \n            if (typeof typeDefinition === 'number') {\n                Object.defineProperty(hostObj, typeName.toUpperCase(), {\n                    value: typeToValueMapping[typeName],\n                    enumerable: true,\n                    writable: false,\n                    configurable: false\n                });\n            }\n            \n            var typeMethodName = getTypeMethodName(typeName);\n            \n            var typeCheckFunction = function(item) {\n                return isType(item, (typeToValueMapping[typeName] || typeName));\n            };\n            \n            hostObj[typeMethodName] = typeCheckFunction;\n            \n            hostObj.not[typeMethodName] = function(value) {\n                return !typeCheckFunction(value);\n            };\n            \n            hostObj.any[typeMethodName] = getInterfaceFunction(typeCheckFunction, false, true, undefined, true);\n            hostObj.all[typeMethodName] = getInterfaceFunction(typeCheckFunction, false, undefined, true, false);\n            hostObj.some[typeMethodName] = getInterfaceFunction(typeCheckFunction, false, true, true, true);\n            hostObj.none[typeMethodName] = getInterfaceFunction(typeCheckFunction, false, true, undefined, false);\n        }\n        \n        /**\n         * Clears the memoization cache of type list strings used in requests.\n         */\n        function clearTypeListStringCache() {\n            typeListStringToTypeIdCache = newObj();\n            typeListStringToTypeIdCacheSize = 0;\n        }\n        \n        /**\n         * Gets the name to be used for the type-matching \n         * method name for the specified type.\n         */\n        function getTypeMethodName(typeName) { \n            var capitalizedTypeName = typeName.toLowerCase().replace(/(^|_)(.)/g, function(match, camelPrefix, camelChar) {\n                return camelChar.toUpperCase();\n            });\n            return 'is' + capitalizedTypeName;\n        }\n        \n        /**\n         * Creates an interface function using the specified parameters.\n         */\n        function getInterfaceFunction(delegateFunction, withTypes, trueCondition, falseCondition, terminationResult) {\n            return function(values, types) {\n                values = (!withTypes && arguments.length > 1 ? arraySlice.call(arguments)\n                        : isArray(values) ? values\n                        : [values]);\n    \n                var trueResult = false,\n                    falseResult = false,\n                    valueIndex;\n                \n                for (valueIndex = 0; valueIndex < values.length; valueIndex++) {\n                    if (delegateFunction(values[valueIndex], types)) {\n                        trueResult = true;\n                    } else {\n                        falseResult = true;\n                    }\n                    if ((trueCondition === undefined || trueResult === trueCondition) && \n                            (falseCondition === undefined || falseResult === falseCondition)) {\n                        return terminationResult;\n                    }\n                }\n                return !terminationResult;\n            };\n        }\n        \n        function capitalize(string) {\n            return string.charAt(0).toUpperCase() + string.slice(1);\n        }\n\n        function throwError(message) {\n            throw new Error(LIB_NAME + ': ' + message);\n        }\n        \n        /*\n         * -----------------\n         * EXTENSIONS MODULE\n         * -----------------\n         */\n        \n        function registerNameScheme(schemeName, schemeAliases) {\n            if (typeof schemeName !== 'string' || schemeName.trim().length === 0 || typeof schemeAliases !== 'object') {\n                return;\n            }\n            var trimSchemeName = schemeName.trim(),\n                existingScheme = nameSchemes[trimSchemeName],\n                newScheme = newObj();\n            \n            objKeys(schemeAliases).forEach(function(typeName) {\n               newScheme[typeName] = schemeAliases[typeName];\n            });\n            \n            nameSchemes[trimSchemeName] = newScheme;\n            return existingScheme;\n        }\n        \n        extensionsModule.registerNameScheme = registerNameScheme;\n        \n        /*\n         * --------------\n         * OPTIONS MODULE\n         * --------------\n         */\n        \n        function setDelimiterPattern(delimiterPattern) {\n            delimiterPattern = ((delimiterPattern === null || delimiterPattern === undefined || delimiterPattern === '') ? \n                    TYPE_DELIMITER_DEFAULT_PATTERN : delimiterPattern);\n            \n            if (typeof delimiterPattern !== 'string') {\n                return;\n            }\n            delimiterPattern = ('[ ]*' + delimiterPattern + '[ ]*');\n            \n            if (typeDelimiterRegExp && (delimiterPattern === typeDelimiterRegExp.source)) {\n                return;\n            }\n            \n            typeDelimiterRegExp = new RegExp(delimiterPattern, 'g');\n            clearTypeListStringCache();\n        }\n        \n        function setNameScheme(nameScheme) {\n            if (nameScheme === undefined || nameScheme === null || nameScheme === NAME_SCHEME_DEFAULT_OPTION_VALUE) {\n                nameScheme = null;\n            }\n            else if (typeof nameScheme === 'string' && (nameScheme in nameSchemes)) {\n                nameScheme = nameSchemes[nameScheme];\n            }\n            if (nameScheme !== null && typeof nameScheme !== 'object') {\n                throwError('Unknown name scheme \"' + nameScheme + '\"');\n            }\n            activeNameScheme = nameScheme;\n            doRefresh();\n        }\n        \n        function setOptions(options) {\n            if (typeof options !== 'object') {\n                return;\n            }\n            objKeys(options).forEach(function(optionName) {\n                var optionMethod = optionsModule['set' + capitalize(optionName)];\n                \n                if (typeof optionMethod === 'function') {\n                    optionMethod(options[optionName]);\n                }\n            });\n        }\n        \n        optionsModule.setDelimiterPattern = setDelimiterPattern;\n        optionsModule.setNameScheme = setNameScheme;\n        optionsModule.set = setOptions;\n\n        /*\n         * --------------\n         * MODULE REFRESH\n         * --------------\n         */\n\n        function coreModuleRefreshHandler() {\n            buildAliasMappings();\n        }\n\n        function doRefresh() {\n            coreModuleRefreshHandler();\n            doModuleTriggeredRefresh(coreModuleRefreshHandler);\n        }\n        \n        var doModuleTriggeredRefresh = (function() {\n\n            var handlersRequestingModuleRefresh = [],\n                isModuleRefreshing = false,\n                isModuleRefreshRequested = false;\n\n            function refreshExtensions(requestingHandlers) {\n                moduleRefreshHandlers.forEach(function(handler) {\n                    /*\n                     * Don't invoke handlers belonging to extensions \n                     * that requested the current refresh.\n                     */\n                    if (requestingHandlers.indexOf(handler) < 0) {\n                        handler.call();\n                    }\n                });\n            }\n\n            /*\n             * Handles extensions' refresh requests by bunching all refresh \n             * requests made during an active refresh into a single subsequent\n             * refresh operation performed on completion of the active refresh.\n             * Also, when the subsequent refresh is processed, excludes handlers \n             * of all the extensions which requested the refresh, in order to \n             * prevent potential cyclic refresh loops in poorly implemented \n             * extensions which may trigger new refreshes while responding to \n             * refresh requests originated by themselves.\n             */\n            return function (requestingHandler) {\n                isModuleRefreshRequested = true;\n\n                if (requestingHandler) {\n                    handlersRequestingModuleRefresh.push(requestingHandler);\n                }\n                if (isModuleRefreshing) {\n                    return;\n                }\n\n                isModuleRefreshing = true;\n\n                while (isModuleRefreshRequested) {\n                    isModuleRefreshRequested = false;\n                    refreshExtensions(handlersRequestingModuleRefresh);\n                }\n\n                handlersRequestingModuleRefresh = [];\n                isModuleRefreshing = false;\n            };\n        })();\n\n        /*\n         * ----------------\n         * ADDON EXTENSIONS\n         * ----------------\n         */\n\n        function registerExtensions(extensions, xtypeModule) {\n            (isArray(extensions) ? extensions : [extensions]).forEach(function(extension) {\n                if (!extension || extension.type !== 'xtypejs' || typeof extension.init !== 'function') {\n                    throwError('Invalid extension - \"type\" property must be \"xtypejs\" and \"init\" property must be a function');\n                }\n                registeredExtensions.push(extension.init);\n                applyExtension(extension.init, xtypeModule);\n            });\n        }\n\n        function applyExtension(extensionInit, hostModule) {\n\n            var moduleRefreshHandler = null,\n\n                extensionInterface = {\n                \n                    getTypeDefinitions: function() {\n                        return typeToValueMapping;\n                    },\n\n                    getNameSchemes: function() {\n                        return nameSchemes;\n                    },\n                    \n                    getActiveNameScheme: function() {\n                        return activeNameScheme;\n                    },\n\n                    defineType: function(typeName, typeValue) {\n                        defineType(typeName, typeValue, hostModule);\n                    },\n\n                    refresh: function() {\n                        doModuleTriggeredRefresh(moduleRefreshHandler);\n                    },\n\n                    setRefreshHandler: function(handler) {\n                        var existingHandlerIndex = moduleRefreshHandlers.indexOf(moduleRefreshHandler || handler);\n\n                        if (existingHandlerIndex > -1) {\n                            moduleRefreshHandlers.splice(existingHandlerIndex, 1);\n                        }\n                        if (typeof handler === 'function') {\n                            moduleRefreshHandlers.push(handler);\n                            moduleRefreshHandler = handler;\n                        }\n                    }\n                };\n\n            extensionInit.call(extensionInterface, hostModule);\n        }\n        \n        /*\n         * ---------------------\n         * MODULE SETUP / EXPORT\n         * ---------------------\n         */\n        \n        function init() {\n            var moduleExport = xtype;\n\n            setDelimiterPattern(TYPE_DELIMITER_DEFAULT_PATTERN);\n            \n            ['Boolean', 'Number', 'String', 'Symbol', 'Function', 'Array', 'Date', 'RegExp', 'Object', 'Error']\n            .forEach(function(objectType) {\n                objToStringToNameMapping['[object ' + objectType + ']'] = objectType.toLowerCase();\n            });\n            \n            defineInterfacePackagesAndMethods(moduleExport);\n            \n            objKeys(TYPE_VALUE_MAPPING).forEach(function(typeName) {\n                defineType(typeName, TYPE_VALUE_MAPPING[typeName], moduleExport);\n            });\n            \n            buildAliasMappings();\n            moduleRefreshHandlers.push(coreModuleRefreshHandler);\n            \n            Object.defineProperty(moduleExport, 'VERSION', {\n                value: (/\\s*{{[^}]*}}\\s*/g.test(LIB_VERSION) ? 'unspecified' : LIB_VERSION),\n                enumerable: true,\n                writable: false,\n                configurable: false\n            });\n            \n            /*\n             * Attach API methods to module export\n             */\n\n            moduleExport.type = type;\n            moduleExport.typeOf = typeOf;\n            moduleExport.which = which;\n            moduleExport.is = isType;\n            \n            moduleExport.ext = extensionsModule;\n            moduleExport.options = optionsModule;\n            \n            moduleExport.newInstance = newModuleInstance;\n\n            moduleExport.ext.registerExtension = function(extensions) {\n                extensions = (arguments.length > 1 ? arraySlice.call(arguments) : extensions);\n                registerExtensions(extensions, moduleExport);\n            };\n            \n            /*\n             * Apply registered extensions on new instance\n             */\n\n            registeredExtensions.forEach(function(extension) {\n                applyExtension(extension, moduleExport);\n            });\n            \n            return moduleExport;\n        }\n        \n        return init();\n    }\n    \n    \n    /*\n     * Export module\n     */\n    var moduleExport = newModuleInstance();\n    \n    \n    if (typeof define === 'function' && define.amd) {\n        define([], function() {\n            return moduleExport;\n        });\n    }\n    else if (typeof module === 'object' && module.exports) {\n        module.exports = moduleExport;\n    }\n    else {\n        moduleExport.noConflict = (function(previouslyDefinedValue) {\n            return function() {\n                root[LIB_NAME] = previouslyDefinedValue;\n                delete moduleExport.noConflict;\n                return moduleExport;\n            };\n        })(root[LIB_NAME]);\n        \n        root[LIB_NAME] = moduleExport;\n    }\n    \n})(this);"]},"metadata":{},"sourceType":"script"}